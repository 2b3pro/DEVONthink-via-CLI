---
status: implemented
keywords: [batch, queue, automation, cli, mcp, optimization]
---

# Batch Operations & Task Queue System

The DEVONthink CLI (`dt`) v2.2.0 introduces a powerful **Task Queue System** designed to handle batch operations efficiently. This system solves two major challenges in automation and AI interactions:

1.  **Performance**: Reduces overhead by bundling multiple operations into single JXA calls (e.g., moving 50 files takes ~0.5s instead of ~10s).
2.  **Context Efficiency**: Allows AI agents (via MCP) to define complex workflows in a single turn, saving tokens and reducing latency.

## Core Concepts

### 1. The Queue (`~/.config/dt/queue.yaml`)
A persistent list of pending actions. You can add tasks sequentially, and the system will execute them in the most efficient way possible.

### 2. Session State (`~/.config/dt/state.yaml`)
Tracks your recent activity (databases, groups, records) and action history. This allows the system to "remember" context across CLI calls.

### 3. Database Cache (`~/.config/dt/databases.yaml`)
Caches database metadata to make listing and searching instantaneous, avoiding expensive AppleScript calls for static data.

---

## CLI Usage

### Managing the Queue

**View Status**
```bash
dt queue status
dt queue list
```

**Add Tasks**
You can add tasks one by one or load them from a file.
```bash
# Add single task
dt queue add create --name "Project Note" --type markdown --database "Inbox"

# Add move task
dt queue add move --uuid "5B6C8..." --destination "/Archive"

# Use the --queue flag on standard commands
dt move <uuid> --to /Archive --queue
dt organize <uuid> --auto --queue
dt summarize <uuid> --native --queue
dt convert <uuid> --to pdf --queue

# Add generic task (JSON output useful for scripting)
dt queue add tag.add --uuids "U1,U2" --tags "important"
```

**Load from File**
Great for bulk operations generated by scripts or other tools.
```bash
dt queue load tasks.json
```
*tasks.json format:*
```json
[
  { "action": "create", "params": { "name": "Doc A", "type": "markdown" } },
  { "action": "move", "params": { "uuid": "...", "destination": "/Trash" } }
]
```

### Executing the Queue

**Validation (Dry Run)**
Check for errors, missing dependencies, or invalid parameters without changing anything.
```bash
dt queue validate
# or
dt queue execute --dry-run
```

**Deep Verification**
Checks if the records, databases, and groups referenced in the queue actually exist in DEVONthink.
```bash
dt queue verify
```

**AI Repair & Restructuring**
If the queue is invalid or a previous execution failed, you can use AI to smartly restructure the queue. The AI analyzes your recent activity context to fix typos, suggest missing groups, or reorder tasks.
```bash
dt queue repair          # Preview AI suggestions
dt queue repair --apply  # Apply AI fixes to the queue
```

**Execution**
Run the pending tasks. The system automatically applies **Look-Ahead Optimization**:
```bash
dt queue execute
```
*Optimization Example:* If the queue contains 10 consecutive `move` tasks, the system detects this and sends a single `batchMove` command to DEVONthink, processing all 10 items in one go.

**Clear Queue**
```bash
dt queue clear           # Clear completed tasks
dt queue clear --scope all # Clear everything
```

---

## MCP Usage (for AI Agents)

The Model Context Protocol (MCP) server exposes special tools for agents to leverage the queue.

### Tools

1.  **`queue_tasks`**
    *   **Description**: Add multiple tasks to the queue.
    *   **Features**: Supports dependency variables (see below).
    *   **Example**:
        ```javascript
        await use_tool("queue_tasks", {
          tasks: [
            { action: "create", params: { name: "Folder", type: "group" } },
            // Reference the UUID of the folder created in task 1
            { action: "move", params: { uuid: "existing-doc", destination: "$1.uuid" } }
          ]
        });
        ```

2.  **`execute_queue`**
    *   **Description**: Run the pending tasks.
    *   **Returns**: A summary of success/failure (terse output to save context tokens).

3.  **`get_queue_status`**
    *   **Description**: Check what's pending or failed.

### Variable Resolution
Tasks can reference the results of previous tasks using the `$ID.field` syntax.

*   `$1.uuid`: The UUID returned by Task 1.
*   `$2.result.path`: The path field from Task 2's result.
*   `$1.uuids`: If Task 1 returned a list (e.g., search results), this expands to that array.

---

## Batch Optimization Strategy

To minimize the "AppleScript penalty" (the overhead of launching `osascript`), the executor uses a **Look-Ahead Bundler**.

**How it works:**
1.  The executor looks at the current pending task (e.g., `move`).
2.  It scans ahead in the queue to find subsequent tasks that are compatible (same action, no inter-dependencies).
3.  It bundles them into a single payload.
4.  It calls a specialized JXA script (e.g., `batchMove.js`) once.

**Supported Batched Actions:**
*   `move`
*   `delete`
*   `tag.add`, `tag.remove`, `tag.set`
*   `modify` (rename, label, rating, etc.)

---

## Configuration

All state files are stored in `~/.config/dt/` in YAML format.

*   **`queue.yaml`**: The active task queue.
*   **`queue.lock`**: Lock file to prevent concurrent writes.
*   **`state.yaml`**: Session history (ring buffers for recent items).
*   **`databases.yaml`**: Cached database list.